name: Build, Push and Deploy to ACK

# 触发器：当有代码push到main分支时
on:
  push:
    branches: [ "main" ]

jobs:
  build-push-and-deploy:
    runs-on: ubuntu-latest # 使用GitHub提供的虚拟机

    steps:
    # ------------------ CI 环节 (我们已完成) ------------------
    # 1. 检出代码
    - name: Checkout code
      uses: actions/checkout@v3

  # (新!) 增加这一步，用来打印出工作目录的文件列表
    - name: List files in workspace
       run: ls -R
    # 2. 登录到阿里云ACR
    - name: Login to ACR
      uses: docker/login-action@v2
      with:
        registry: ${{ secrets.ACR_REGISTRY }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}

    # 3. 构建并推送Docker镜像
    - name: Build and push Docker image
      id: build-image # (新!) 给这一步起个ID，方便后面引用它的输出
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ secrets.ACR_REGISTRY }}/${{ secrets.ACR_NAMESPACE }}/my-cicd-demo:${{ github.sha }}

 # ... (前面 build-push-and-deploy 和 Set up Kubeconfig 的步骤保持不变) ...

    # ------------------ CD 环节 (修正版!) ------------------
    # 4. 配置kubectl的“指挥部通行证”
    - name: Set up Kubeconfig
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.ACK_KUBECONFIG }}

   # 5. 部署到ACK集群 (最终修正版)
    - name: Deploy to ACK
      run: |
        # 我们在这里，重新构建出那个我们推送到ACR时，使用的完整的、正确的镜像“姓名”
        export IMAGE_WITH_TAG="${{ secrets.ACR_REGISTRY }}/${{ secrets.ACR_NAMESPACE }}/my-cicd-demo:${{ github.sha }}"
        
        echo "Deploying to ACK cluster with new image tag: ${IMAGE_WITH_TAG}"
        
        # 使用这个正确的“姓名”去更新部署
        kubectl set image deployment/nginx-deployment nginx=${IMAGE_WITH_TAG}
        
        echo "Waiting for deployment rollout to finish..."
        kubectl rollout status deployment/nginx-deployment